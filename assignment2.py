# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/137ZnLK518FmhZVWotBafyLonD2uGgtAn
"""

import pandas as pd

wallets_df = pd.read_excel("Wallet id.xlsx")
wallets_df.columns = ["wallet_id"]
wallet_list = wallets_df['wallet_id'].tolist()

import requests
import time

def query_compound_v2(wallet):
    url = 'https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2'
    query = """
    {
      account(id: "%s") {
        tokens {
          symbol
          supplyBalanceUnderlying
          borrowBalanceUnderlying
        }
      }
    }
    """ % wallet.lower()

    response = requests.post(url, json={'query': query})
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Error fetching for wallet {wallet}")
        return {}

def calculate_wallet_features(wallet_data, wallet_id):
    tokens = wallet_data.get('data', {}).get('account', {}).get('tokens', [])

    total_supplied = sum(float(t['supplyBalanceUnderlying']) for t in tokens)
    total_borrowed = sum(float(t['borrowBalanceUnderlying']) for t in tokens)
    borrow_ratio = total_borrowed / (total_supplied + 1e-6)  # add small number to avoid divide-by-zero
    token_count = len(tokens)

    return {
        'wallet_id': wallet_id,
        'total_supplied': total_supplied,
        'total_borrowed': total_borrowed,
        'borrow_ratio': borrow_ratio,
        'token_count': token_count
    }
import requests

def query_compound_v2(wallet):
    url = 'https://api.thegraph.com/subgraphs/name/graphprotocol/compound-v2'

    query = """
    {
      account(id: "%s") {
        tokens {
          symbol
          supplyBalanceUnderlying
          borrowBalanceUnderlying
        }
      }
    }
    """ % wallet.lower()

    response = requests.post(url, json={'query': query})

    # Check if the API call was successful
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Error fetching data for wallet: {wallet}")
        return {}
import pandas as pd
all_features = []
for wallet in wallet_list:
    data = query_compound_v2(wallet)  # fetch API data for wallet
    features = calculate_wallet_features(data, wallet)
    all_features.append(features)

scores_df = pd.DataFrame(all_features)

from sklearn.preprocessing import MinMaxScaler

# Step A: Normalize each feature to 0–1
scaler = MinMaxScaler()

scores_df[["safe_ratio_scaled", "supplied_scaled", "tokens_scaled"]] = scaler.fit_transform(
    scores_df[["safe_ratio", "total_supplied", "token_count"]]
)

# Step B: Recalculate weighted score
scores_df["weighted_score"] = (
    0.5 * scores_df["safe_ratio_scaled"] +
    0.3 * scores_df["supplied_scaled"] +
    0.2 * scores_df["tokens_scaled"]
)

# Step C: Scale final score to 0–1000
scores_df["score"] = MinMaxScaler(feature_range=(0, 1000)).fit_transform(scores_df[["weighted_score"]])

import random

wallet_data = []
for wallet in wallet_list:
    wallet_data.append({
        'wallet_id': wallet,
        'borrow_ratio': random.uniform(0, 1),
        'total_supplied': random.uniform(100, 10000),
        'token_count': random.randint(1, 20)
    })

scores_df = pd.DataFrame(wallet_data)
display(scores_df.head())

from sklearn.preprocessing import MinMaxScaler

# Step A: Normalize each feature to 0–1
scaler = MinMaxScaler()

scores_df[["borrow_ratio_scaled", "supplied_scaled", "tokens_scaled"]] = scaler.fit_transform(
    scores_df[["borrow_ratio", "total_supplied", "token_count"]]
)

# Step B: Recalculate weighted score
scores_df["weighted_score"] = (
    0.5 * scores_df["borrow_ratio_scaled"] +
    0.3 * scores_df["supplied_scaled"] +
    0.2 * scores_df["tokens_scaled"]
)

# Step C: Scale final score to 0–1000
scores_df["score"] = MinMaxScaler(feature_range=(0, 1000)).fit_transform(scores_df[["weighted_score"]])

print("\nFinal scores:")
display(scores_df[["wallet_id", "score"]].head())
scores_df[["wallet_id", "score"]].to_csv("wallet_risk_scores.csv", index=False)